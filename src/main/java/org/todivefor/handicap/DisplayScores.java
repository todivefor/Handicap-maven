/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.todivefor.handicap;

import java.awt.Component;
import java.awt.HeadlessException;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.prefs.BackingStoreException;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.SwingConstants;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import net.proteanit.sql.DbUtils;
import org.todivefor.iconutils.IconUtils;
import org.todivefor.stringutils.StringUtils;

/**
 *
 * @author peterream
 */
public class DisplayScores extends javax.swing.JPanel
{
    
    public static boolean scoreEditingAllowed = true;           // Don't allow edit on tournament display
    public static boolean scoreDataChanged = true;              // Need to recalc index?
    public static boolean tournament = false;                   // Displaying tournament scores

    public static String saveDate;                              // Save score date (yyyy-MM-dd)
    private static boolean runDateWorldHandicap = false;        // World Handicap run date
    private static boolean worldHandicap = false;               // World Handicap
    private static int archiveYr = 0;                           // Archive year
       
    public static boolean newWHFileFormat;                      // File format with PCC
//    
    public static int uPosition = HandicapMain.U_POS;           // U table position (variable, based on PCC)

    /**
     * Creates new form DisplayScores
     */
    public DisplayScores()
    {
        initComponents();
        
        Calendar now = Calendar.getInstance();
        System.out.println("Run date is : " + (now.get(Calendar.MONTH) + 1) + "/" + 
                now.get(Calendar.DATE) + "/" + 
                now.get(Calendar.YEAR));
        if (now.get(Calendar.YEAR) >= (HandicapMain.WORLDHCYEAR))   // World HC?
            runDateWorldHandicap = true;                            // Yes
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {
        java.awt.GridBagConstraints gridBagConstraints;

        scrollPane = new javax.swing.JScrollPane();
        tableDisplayScores = new javax.swing.JTable();
        panelCenter = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        textDisplayScoresNumberScores = new javax.swing.JTextField();
        textDisplayScoresIndex = new javax.swing.JTextField();
        textDisplayScoresAverageScore = new javax.swing.JTextField();
        btnCalculateCourseHandicap = new javax.swing.JButton();
        textDisplayScoresIndexAdj = new javax.swing.JTextField();
        textDisplayScoresIndexAdj.setVisible(false);
        panelSouth = new javax.swing.JPanel();
        btnBack = new javax.swing.JButton();

        setLayout(new java.awt.BorderLayout());

        tableDisplayScores.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][]
            {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String []
            {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        tableDisplayScores.addMouseListener(new java.awt.event.MouseAdapter()
        {
            public void mouseClicked(java.awt.event.MouseEvent evt)
            {
                tableDisplayScoresMouseClicked(evt);
            }
        });
        scrollPane.setViewportView(tableDisplayScores);

        add(scrollPane, java.awt.BorderLayout.PAGE_START);

        java.awt.GridBagLayout panelCenterLayout = new java.awt.GridBagLayout();
        panelCenterLayout.columnWidths = new int[] {0, 15, 0, 15, 0, 15, 0};
        panelCenterLayout.rowHeights = new int[] {0, 10, 0, 10, 0};
        panelCenter.setLayout(panelCenterLayout);

        jLabel1.setText("Number Scores");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        panelCenter.add(jLabel1, gridBagConstraints);

        jLabel2.setText("Index");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        panelCenter.add(jLabel2, gridBagConstraints);

        jLabel3.setText("Average Score");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        panelCenter.add(jLabel3, gridBagConstraints);

        textDisplayScoresNumberScores.setText("999");
        textDisplayScoresNumberScores.setFocusable(false);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        panelCenter.add(textDisplayScoresNumberScores, gridBagConstraints);

        textDisplayScoresIndex.setText("99.9");
        textDisplayScoresIndex.setFocusable(false);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        panelCenter.add(textDisplayScoresIndex, gridBagConstraints);

        textDisplayScoresAverageScore.setText("999.9");
        textDisplayScoresAverageScore.setFocusable(false);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        panelCenter.add(textDisplayScoresAverageScore, gridBagConstraints);

        btnCalculateCourseHandicap.setText("Calculate Course Handicaps");
        btnCalculateCourseHandicap.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                btnCalculateCourseHandicapActionPerformed(evt);
            }
        });
        panelCenter.add(btnCalculateCourseHandicap, new java.awt.GridBagConstraints());

        textDisplayScoresIndexAdj.setText("99.9N");
        textDisplayScoresIndexAdj.setFocusable(false);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 2;
        panelCenter.add(textDisplayScoresIndexAdj, gridBagConstraints);

        add(panelCenter, java.awt.BorderLayout.CENTER);

        btnBack.setIcon(IconUtils.getNavigationIcon("Back", 24));
        btnBack.setText("Back");
        btnBack.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                btnBackActionPerformed(evt);
            }
        });
        panelSouth.add(btnBack);

        add(panelSouth, java.awt.BorderLayout.PAGE_END);
    }// </editor-fold>//GEN-END:initComponents

    private void btnBackActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_btnBackActionPerformed
    {//GEN-HEADEREND:event_btnBackActionPerformed
        archiveYr = 0;                                      // Turn off in case displaying archive
        tournament = false;                                 // Set not tournament score display
        scoreEditingAllowed = true;                         // Allow editing of scores
        refreshScoreTable(HandicapMain.scoreTableName);     // Refresh scores table
        HandicapMain.resetTitle();                          // Set title in frame
        HandicapMain.lastCard = HandicapMain.MAINMENU;      // Force MAINMENU
        AddScores.txtAddScoresPCC.setVisible(false);        // Make PCC invisible
        AddScores.lblAddScoresPCC.setVisible(false);        // Make PCC label invisible
        HandicapMain.cards.show(getParent(), 
            (String) HandicapMain.returnStack.pop());   // Show MAINMENU
    }//GEN-LAST:event_btnBackActionPerformed

    private void tableDisplayScoresMouseClicked(java.awt.event.MouseEvent evt)//GEN-FIRST:event_tableDisplayScoresMouseClicked
    {//GEN-HEADEREND:event_tableDisplayScoresMouseClicked
        HandicapMain.setFrameTitle("Handicap Edit Score - " + HandicapMain.userName); // Set title					//  <date change>
        if (!scoreEditingAllowed)		// Are we in an archive / tournament display
        {
            JOptionPane.showMessageDialog(null, "Editing is not allowed");  // Yes - display message
            return;                                                         // Return   
        }
            
        String duplicateID = "";                                        // Duplicate IDer (T00:01)
        int duplicateCount = 0;                                         // Duplicate counter
        Boolean tryDuplicate = true;
        int row = tableDisplayScores.getSelectedRow();                  // Get selected row
        String DATE_ = tableDisplayScores.getModel().getValueAt(row,
                HandicapMain.DATE_POS).toString();                      // Date (mm/dd/yy) from display
        String ymdDate = AddScores.convertTableDate(DATE_);             // Convert display date to table date
        while (tryDuplicate)
        {
            // MM/dd/yy -> yyyy-MM-dd

//          Select * from SCORE_TBL where DateField = yyyyMMdd				
            String query = "Select * from " + HandicapMain.scoreTableName
                    + " where DateField = '" + ymdDate + duplicateID + "'";
            //	    String query = "Select * from " + scoreTableName + " where Date = '"+DATE_+"'";
            try (PreparedStatement pst = SQLiteConnection.connection.
                    prepareStatement(query);                            // PST with resources
                ResultSet rs = pst.executeQuery())                      // Execute query

            {
//  TODO    Multiple scores for same day are deleted in order entered
                if (rs.next())                                          // Found date?
                {
                    saveDate = rs.getString("DateField");               // Save off date in case we are changing it
                    // convert to date
                    AddScores.dateChooserAddScoresDate.
                            setDate(convertDate(saveDate));             // <date change>
                    AddScores.comboBoxCourse.
                            setSelectedItem(rs.getString("Course"));    // Course to combo box
                    AddScores.textFieldScore.
                            setText(rs.getString("Score"));             // Score
                    AddScores.textFieldCourseRating.
                            setText(rs.getString("Rating"));            // Rating
                    AddScores.textFieldCourseSlope.
                            setText(rs.getString("Slope"));             // Slope
                    AddScores.txtAddScoresPCC.
                            setText(rs.getString("PCC"));               // PCC
                    AddScores.btnAddScoresAdd.
                            setText("Update");                          // change button to update in Add Score
                    AddScores.btnAddScoreDelete.
                            setVisible(true);                           // Make delete button visible
                    AddScores.lblAddScoresPCC.setVisible(true);         // Set PCC label to visible
                    AddScores.txtAddScoresPCC.setVisible(true);         // Set PCC field to visible

/*
*
* 		inicatorTournOrNineOnDB indicates T or 9 set in DB record
*                   We use this to set respective chckbox indicator here
*                   We will also use it in "delete" or "update" routines to 
*                       determine if changed (ie on to off or off to on)
*
*/
                    HandicapMain.inicatorTournOrNineOnDB = rs.
                            getString(HandicapMain.TOURNINDICATOR);         // Tournament or 9 hole
                    if (HandicapMain.inicatorTournOrNineOnDB != null)       // null causes probs with switch
                    {
                        switch (HandicapMain.inicatorTournOrNineOnDB)       // T / 9
                        {
                            case HandicapMain.TOURNINDICATOR:               // T
                                AddScores.chckbxAddScoresTournamentScore.
                                        setSelected(true);                  // Set tournament
                                break;

                            case HandicapMain.NINEINDICATOR:                // 9
                                AddScores.chckbxAddScoresNineHoleScore.
                                        setSelected(true);                  // Set 9 hole
                                break;
                        }
                    }
                    tryDuplicate = false;                                           // Found record quit
                }
                else                                                                // Date not found
                {
                    System.out.println("Must be an auto-incremented date record");  // Must be an auto incremented date
                    duplicateCount++;                                               // Increment duplicates
                    duplicateID = "T00:0" + duplicateCount;                         // Turn on duplicate ID
                    if (duplicateCount > 3)                                         // Allow only 3 for same day
                    {
                        tryDuplicate = false;                                       // Get out
                    }
                }
                // Close result set
                // Close PST
            } 
            catch (HeadlessException | SQLException e1)                             // Exeception from query
            {
                e1.printStackTrace();                                               // Print stacktrace
            }
//				AddScores.textFieldScore.requestFocusInWindow();		// set focus to score
        }                                                                           // End while
            HandicapMain.returnStack.push(HandicapMain.DISPLAYSCORES);              // push DISPLAYSCORES onto returnStack
            HandicapMain.cards.show(getParent(), "AddScores");
    }//GEN-LAST:event_tableDisplayScoresMouseClicked

    private void btnCalculateCourseHandicapActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_btnCalculateCourseHandicapActionPerformed
    {//GEN-HEADEREND:event_btnCalculateCourseHandicapActionPerformed
//        HandicapMain.whereTReturn = HandicapMain.DISPLAYSCORES;                // Return to display scores
        HandicapMain.returnStack.push(HandicapMain.DISPLAYSCORES);              // Return to display scores
        scoreEditingAllowed = false;                                            // Don't allow editing of scores
        String hIndexStr = textDisplayScoresIndex.getText();                    // Get index from text
        if (hIndexStr.equals("NH"))                                             // Have more than 5 scores?
        {
            JOptionPane.showMessageDialog(null, "Not enough scores to calculate course handicaps"); // No
            scoreDataChanged = true;						// Force redisplay of scores
            return;								// Get out of here
        }
//      select Name, Rating, Slope, Rating as 'Course Handicap' from COURSE_TBL Order by Name
        String query = "select Name, Rating, Slope, Par, Par as 'Course Handicap' from "
                + HandicapMain.courseTableName + " Order by Name";

        try (PreparedStatement pst = SQLiteConnection.connection.
                prepareStatement(query);                            // PST
            ResultSet rs = pst.executeQuery())                      // Execute query to get courses
        {
            tableDisplayScores.setModel(DbUtils.resultSetToTableModel(rs));
            // Close result set
            // Close PST
        }
        catch (SQLException e1)
        {
            e1.printStackTrace();
        }
/*
 * 	Loop through tableDisplayScores (actually courses)
 * 	calculate course handicap and put in third column
 * 
 * 	0 - Course, 1 - Rating, 2 - Slope, 3 - rating where 
 * 	we will display course handicap
 */

        double hIndex = Double.parseDouble(textDisplayScoresIndex.getText());	// Index
        String hIndexAdjStr = textDisplayScoresIndexAdj.getText();		// Adjusted index
        if (!hIndexAdjStr.equals("99.9N"))                                      // Adjusted index?
//        if (hIndexAdjStr.length() != 0)
        {
            hIndexAdjStr = hIndexAdjStr.substring(0, hIndexAdjStr.length() - 1); // Yes, strip off R
            if (StringUtils.isStringNumeric(hIndexAdjStr))
            {
                hIndex = Double.parseDouble(hIndexAdjStr);			// Use adjusted	
            }
        }

        int lastRow = tableDisplayScores.getRowCount();				// Rows in table
        double courseRating;
        int coursePar;
        for (int row = 0; row < lastRow; row++)					// Loop thru all courses
        {
            
            double whcAdjust = 0;                                               // Default to non WHC
            if (worldHandicap)                                                  // WHC?
            {                                                                   // Yes, adjust
                courseRating = (double) tableDisplayScores.getModel().
                    getValueAt(row, 1);                                         // Course rating from JTable
                Object courseParS = tableDisplayScores.getModel().
                    getValueAt(row, 3);
                if (courseParS != null)                                         // Par in table?
                    coursePar = (int) tableDisplayScores.getModel().
                        getValueAt(row, 3);                                     // Yes, course par from JTable
                else
                    coursePar = 72;                                             // No, just default to 72
                whcAdjust = courseRating - coursePar;                           // Course rating minus par
            }
            
            int courseSlope;
            courseSlope = (int) tableDisplayScores.getModel().
                    getValueAt(row, 2);						// Slope

            double courseSlopeD = courseSlope;
            double courseIndex = (hIndex * (courseSlopeD / 113F)) +
                    whcAdjust;                                                  // CI = (HI * course slope) / 113 + WHCadj
            int courseIndexI = (int) Math.floor(courseIndex + .5F);		// Round to whole number
            tableDisplayScores.setValueAt(String.valueOf(courseIndexI), row, 4);    // Course index
        }
        renderColumns(tableDisplayScores);                                      // Set column sizes for table tableDisplayCourses
        scoreDataChanged = true;						// Force redisplay of scores
    }//GEN-LAST:event_btnCalculateCourseHandicapActionPerformed

    /*
    Beginning of common methods within DisplayScores class
    */
    
    /**
     * This method converts yyyy-MM-dd string to date
     * @param dateInString
     * @return 
     */
    
    private static java.util.Date convertDate(String dateInString)
    {
        java.util.Date date = null;
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
//	  		SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yy");	// <date change>
        try
        {
            date = formatter.parse(dateInString);
            if (HandicapMain.debug)
            {
                System.out.println("String Date in: " + dateInString);
                System.out.println("Date Date after parsing: " + date);
                System.out.println("String Date as returned: " + formatter.format(date));
            }
        } catch (ParseException e)
        {
            e.printStackTrace();
        }
        return date;
    }
/**
 * This method displays the score table
 * @param scoreTableName
 */
    public static void refreshScoreTable(String scoreTableName)
    {
        if (scoreTableName.contains("_YrEnd"))
        {
            archiveYr = Integer.parseInt(scoreTableName.
                    substring(11, 15));                         // Get archive year
        }
/*
 * 			Display date mm/dd/yy
 */
//  TODO    Add duplicate ID to process multiple scores on same day

        worldHandicap = runDateWorldHandicap;                           // Let run date determine WHC
        newWHFileFormat = true;                                         // File contains PCC
        if (archiveYr > 0)                                              // Displaying archive data?
        {
            if (archiveYr >= HandicapMain.WORLDHCYEAR)                  // Archive yr after WH?
            {
                worldHandicap = true;                                   // Yes, set WH on
                newWHFileFormat = true;                                 // File contains PCC
            }
            else
            {
                worldHandicap = false;                                  // No
                newWHFileFormat = false;                                // File does not contain PCC
            }
        }
        
        String selectTourn = "";                                        // Select all
         if (tournament)
             selectTourn = " where T = '" + "T" + "' ";                 // Select on tourn
         
        String addPCC = "PCC, ";                                        // For when PCC needed        
        if (worldHandicap)                                              // World Handicap?
        {
            uPosition = HandicapMain.U_POS;                             // Yes, PCC
        }
        else
         {
            addPCC = "";                                                // No, no PCC
            uPosition = HandicapMain.U_POS - 1;                         // Account
//            ratingPosition--;                                           //  for
//            slopePosition--;                                            //      no
//            differentialPosition--;                                     //          PCC column
        }           
        String query = "select strftime('%m/%d/', DateField) || substr(strftime('%Y', DateField),3, 2) as Date,"
                + "Course as 'Course Name',"
                + " T, Score," + addPCC + "U,"
                + "Rating, Slope,"
                + " Differential as 'Index'"
//                    + " from " + scoreTableName + " where T = '" + "T" + "' Order by DateField DESC";
                + " from " + scoreTableName + selectTourn + " Order by DateField DESC";
//        }
        try (PreparedStatement pst = SQLiteConnection.connection.
                prepareStatement(query);                            // PST
                ResultSet rs = pst.executeQuery())                  // Execute query
            /*
             * RS2XML - ResultSet
             *
             * Load table using rs2xml.jar video 12
             *
             * @see
             * https://www.youtube.com/watch?v=6cNYUc2PIag&list=PLS1QulWo1RIbYMA5Ijb72QHaHvCrPKfS2&index=12
             * https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwip2K3KnuHKAhULlh4KHYa3AOUQFggcMAA&url=http%3A%2F%2Fsourceforge.net%2Fprojects%2Ffinalangelsanddemons%2F&usg=AFQjCNG_PLve63VxZe5Mg0niMGgRtZolPQ&sig2=V4xTJprXP6xgkFmTMf06LA&bvm=bv.113370389,d.dmo
             *
             */ 
        {
            DisplayScores.tableDisplayScores.setModel(DbUtils.resultSetToTableModel(rs));
        }
/*
             * RS2XML - ResultSet
             *
             * Load table using rs2xml.jar video 12
             *
             * @see
             * https://www.youtube.com/watch?v=6cNYUc2PIag&list=PLS1QulWo1RIbYMA5Ijb72QHaHvCrPKfS2&index=12
             * https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwip2K3KnuHKAhULlh4KHYa3AOUQFggcMAA&url=http%3A%2F%2Fsourceforge.net%2Fprojects%2Ffinalangelsanddemons%2F&usg=AFQjCNG_PLve63VxZe5Mg0niMGgRtZolPQ&sig2=V4xTJprXP6xgkFmTMf06LA&bvm=bv.113370389,d.dmo
             *
             */
/*
             * RS2XML - ResultSet
             *
             * Load table using rs2xml.jar video 12
             *
             * @see
             * https://www.youtube.com/watch?v=6cNYUc2PIag&list=PLS1QulWo1RIbYMA5Ijb72QHaHvCrPKfS2&index=12
             * https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwip2K3KnuHKAhULlh4KHYa3AOUQFggcMAA&url=http%3A%2F%2Fsourceforge.net%2Fprojects%2Ffinalangelsanddemons%2F&usg=AFQjCNG_PLve63VxZe5Mg0niMGgRtZolPQ&sig2=V4xTJprXP6xgkFmTMf06LA&bvm=bv.113370389,d.dmo
             *
             */
        catch (Exception e1)
        {
            if (HandicapMain.debug)
            {
                e1.printStackTrace();
            }
            return;                                             // If error, just get out of here
        }

/*
 * 
 * 			Calculate how wide to make each column
 * 		
 */
//			int preferredWidth = 0;
//			Force some widths (Date, T, Score, U)

        int width = 95;                         //		Date column
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(HandicapMain.DATE_POS).setMinWidth(width);
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(HandicapMain.DATE_POS).setMaxWidth(width);
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(HandicapMain.DATE_POS).setPreferredWidth(width);
        width = 40;				//		T column
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(HandicapMain.T_POS).setMinWidth(width);
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(HandicapMain.T_POS).setMaxWidth(width);
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(HandicapMain.T_POS).setPreferredWidth(width);
                                                //		U column
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(uPosition).setMinWidth(width);
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(uPosition).setMaxWidth(width);
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(uPosition).setPreferredWidth(width);

        width = 60;				//		Score column
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(HandicapMain.SCORE_POS).setMinWidth(width);
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(HandicapMain.SCORE_POS).setMaxWidth(width);
        DisplayScores.tableDisplayScores.getColumnModel().getColumn(HandicapMain.SCORE_POS).setPreferredWidth(width);

        renderColumns(DisplayScores.tableDisplayScores);                            // Set column sizes for table tableDisplayScores

//			recalcHandicapIndex = false;				// Don't recalculate until needed
/*
 * 			Calculate Handicap index
 */
        DisplayScores.textDisplayScoresIndexAdj.setVisible(false);                  // Set adjusted field invisible, assume no adj
        String hi = "NH";                                                           // Assume not enough scores
        DisplayScores.textDisplayScoresIndex.setText(hi);                           // Put in display								

        HandicapIndices handicapIndex = calculateHandicapIndex(DisplayScores.
                tableDisplayScores);                                                // Calculate handicap index and mark used scores

        if (handicapIndex.newIndex != -99)                                          // Calculate index?
        {
            hi = String.valueOf(Math.floor(handicapIndex.newIndex * 10) / 10);      // Calculated index
            DisplayScores.textDisplayScoresIndex.setText(hi);                       // Set handicap Index without adjustment
        }
        if (handicapIndex.newIndexAdjusted != -99)                                  // Tournament adjustment?
        {
            if (worldHandicap)                                                      // World HC?
            {                                                                       // Yes
                if (handicapIndex.newIndexAdjusted != -99)                          // Soft/Hard adjustment?
                {
                    hi = String.valueOf(Math.floor(handicapIndex.newIndexAdjusted 
                            * 10) / 10);                                            // NN.N
                    DisplayScores.textDisplayScoresIndexAdj.setText(hi + 
                            handicapIndex.adjustedType);                            // Set handicap Index with adjustment
                    DisplayScores.textDisplayScoresIndexAdj.setVisible(true);       // Set adjusted field visible
                }
            }
            else                                                                    // No - tournament calc
            {
                hi = String.valueOf(Math.floor((handicapIndex.newIndex - 
                        handicapIndex.newIndexAdjusted) * 10) / 10);                // Calculated index
                DisplayScores.textDisplayScoresIndexAdj.setText(hi +
                        handicapIndex.adjustedType);                                // Set handicap Index with adjustment
                DisplayScores.textDisplayScoresIndexAdj.setVisible(true);           // Set adjusted field visible
            }
        }
        
//      Save HI for calculation next time

        String userHANDICAPHI = HandicapMain.userName + HandicapMain.HANDICAPHI;
        HandicapMain.handicapPrefs.put(userHANDICAPHI, hi);                         //  Save prev HI
        try                              
        {
            HandicapMain.handicapPrefs.flush();                                     // Make all preferences changes permanent
        }
        catch (BackingStoreException ex)
        {
            Logger.getLogger(HandicapMain.class.getName()).log(Level.SEVERE, 
                    null, ex);
        }
     
    }
    
/**
 * This method will take a table (score table or course table) as input
 * It will check the data of each column and set the width based on the data
 * 
 * @param tableToRender
 */
		
    public static void renderColumns(JTable tableToRender)
    {
        int width;
        for (int column = 0; column < tableToRender.getColumnCount(); column++)     // Trip through columns
        {
            TableColumn tableColumn = tableToRender.getColumnModel().
                    getColumn(column);

            int preferredWidth = tableColumn.getMinWidth();
            int maxWidth = tableColumn.getMaxWidth();

            /*
             * 		This processes the data of the table, excluding the header row
             */
            for (int row = 0; row < tableToRender.getRowCount(); row++)             // Trip through rows
            {
                TableCellRenderer cellRenderer = tableToRender.getCellRenderer
                        (row, column);
                Component c = tableToRender.prepareRenderer
                        (cellRenderer, row, column);
                width = c.getPreferredSize().width + tableToRender.
                        getIntercellSpacing().width;
                preferredWidth = Math.max(preferredWidth, width);

                //  We've exceeded the maximum width, no need to check other rows
                if (preferredWidth >= maxWidth)
                {
                    preferredWidth = maxWidth;
                    break;
                }
            }
            tableColumn.setPreferredWidth(preferredWidth);	// Set column width

            // Centers SCORE data in table
            DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
            centerRenderer.setHorizontalAlignment(SwingConstants.CENTER);		// Assuming to center
            /*
	 * 		If L & F is "System", columns are left justified
	 * 			therefore make data left justified (at least for Mac and Windows)		
             */
//			String lAndF = getLookAndFeel();				// Get look & feel
            if (HandicapMain.lookAndFeel.equals("System") || HandicapMain.lookAndFeel.equals("Nimbus"))
            {
                centerRenderer.setHorizontalAlignment(SwingConstants.LEFT);		// Make left
            }
            /*
             * 		L & F "Windows", columns are left justified
             * 			therefore make data left justified (at least for Mac and Windows)
             */
            if (HandicapMain.operatingSystem.startsWith("Win"))
            {
                if (HandicapMain.lookAndFeel.equals("Windows"))
                {
                    centerRenderer.setHorizontalAlignment(SwingConstants.LEFT);		// Make left
                }
            }

            tableToRender.getColumnModel().getColumn(column).setCellRenderer(centerRenderer);
        }

    }

        public static class HandicapIndices
        {
            Double newIndex;                                                        // Calculated HI
            Double newIndexAdjusted;                                                // Adjusted index
            String adjustedType;                                                    // Type of adjustment                                                 
        }
    
/**
 * 	Method will calculate handicap index from differentials in JTABLE tableDisplayScores
 * 
 * handicap index = AVG (differentials) * .96 (truncated to tenths)
 * 
 * @param tableDisplayScores
 * @return 
 */
    public static HandicapIndices calculateHandicapIndex(JTable tableDisplayScores) 
    {
        class Indices
        {
            public double differential;
            public int tableRowNumber;
        }
        HandicapIndices hiIndex = new HandicapIndices();
        if (Preferrences.chkBoxPreferencesWHC.
                isSelected())                           // Non-WHC?
            worldHandicap = false;                      // Yes
        Boolean exceptionalScore = false;               // Not an exceptional score
        double[] handicapIndexR = new double [2];
        hiIndex.newIndex = -99D;                       // Set to no handicap index
        hiIndex.newIndexAdjusted = -99D;                       // Set to no handicap index adjustment
        double handicapIndex = -99D;                    // Handicap index, -99 not enough scores
        int numberTournamentScores = 0;                 // Number of tournament scores
        double saveDifferential;                        // Save differential for ease
        double tournLowDiffOne = 99;                    // Tournament low 1
        double tournLowDiffTwo = 99;                    // Tournament low 2

        int lastRow = tableDisplayScores.getRowCount();	// Rows in table
        int numberNonNineHoleScores = lastRow;		// Number non-9 hole scores

        if (lastRow < 1)					// Empty?
        {
            hiIndex.newIndex = handicapIndex;		// yes - return -99
            return hiIndex;
        }
        int scoresInCurrentRecord = 20;				// # scores in current record - assume 20
        if (lastRow < 20)					// More than 20 scores?
        {
            scoresInCurrentRecord = lastRow;		// Get scores we have
        }

        Indices[] indexArray = new Indices [scoresInCurrentRecord];	// Array of indices # up to 20
/*
 * 
 * 			Build array of Indices object
 * 				double differential
 * 				int table row number
 */
        int numberNonNineHoleScoresInCurrentRecord = 0;
        int totalOfAllScores = 0;                                   // Accumulate all scores
        int diffPosition = HandicapMain.DIFFERENTIAL_POS - 1;   // Position of differential old format
        if (newWHFileFormat)
            diffPosition++;                                     // Position of differential new format
        for (int row = 0; row < lastRow; row++)                     // Loop thru all scores
        {
            String t = (String) tableDisplayScores.getModel().
                    getValueAt(row, HandicapMain.T_POS);            // Index row
            if (row < scoresInCurrentRecord)                        // Process current scoring record
            {                                                       // Last 20 or less

//				Process scores in current scoring record

                if ((t == null) || (!(t.equals(HandicapMain.NINEINDICATOR))))                   // Nine hole score?
                {
                    indexArray[numberNonNineHoleScoresInCurrentRecord] = new Indices();		// No - process
//                    if (worldHandicap)
//                      Check for exceptional score marker (!) following differential
                        String differTest = tableDisplayScores.getModel().
                                getValueAt(row, diffPosition).toString();           // String differential
                        if (!StringUtils.isStringNumeric(differTest))               // Is there an exceptioanl marker?
                        {
                            differTest = differTest.replaceAll("!", "");            // Get rid of exceptional score marker for calc
                            exceptionalScore = true;                                // This is an exceptional score
                        }
                        Double differTestDbl = Double.parseDouble(differTest);
                        indexArray[numberNonNineHoleScoresInCurrentRecord].
                            differential = saveDifferential = differTestDbl;
                        
//                        indexArray[numberNonNineHoleScoresInCurrentRecord].
//                            differential = saveDifferential = 
//                            (double) tableDisplayScores.getModel().
//                            getValueAt(row, diffPosition);                          // differential

//                    else
//                        indexArray[numberNonNineHoleScoresInCurrentRecord].
//                            differential = saveDifferential = 
//                            (double) tableDisplayScores.getModel().
//                            getValueAt(row, HandicapMain.DIFFERENTIAL_POS - 1);   // differential (missing PCC)
                    indexArray[numberNonNineHoleScoresInCurrentRecord].
                            tableRowNumber = row;                               // row #
                    numberNonNineHoleScoresInCurrentRecord++;                   // Count non 9 hole scores in record
//					System.out.println("Row: " + indexArray[row].tableRowNumber + " Index: " + indexArray[row].differential);
                }
                else									// Yes 9 hole - skip
                {
                    totalOfAllScores = totalOfAllScores - (int) tableDisplayScores.
                                    getModel().getValueAt(row,
                                            HandicapMain.SCORE_POS);                // Subtract 9 hole score
                                                                                    // we are going to add in later
                    numberNonNineHoleScores = lastRow - 1;                          // # scores that are not 9 holes
                    if (scoresInCurrentRecord < lastRow)                            // Do we have 20?
                    {
                            scoresInCurrentRecord++;                                // Process 1 more for current record
                    }

                }

            }
//            if (worldHandicap)
//              Check for exceptional score marker (!) following differential
                String differTest = tableDisplayScores.getModel().
                        getValueAt(row, diffPosition).toString();           // String differential
                if (!StringUtils.isStringNumeric(differTest))
                    differTest = differTest.replaceAll("!", "");
                Double differTestDbl = Double.parseDouble(differTest);
                saveDifferential = differTestDbl;
                
//                saveDifferential = (double) tableDisplayScores.getModel().
//                    getValueAt(row, diffPosition);                                  // Save differential for tournament processing

//            else
//                saveDifferential = (double) tableDisplayScores.getModel().
//                    getValueAt(row, HandicapMain.DIFFERENTIAL_POS - 1);             // Save differential for tournament processing
            totalOfAllScores = totalOfAllScores + (int) tableDisplayScores.
                            getModel().getValueAt(row, HandicapMain.SCORE_POS);     // Add score to total
            if (!worldHandicap)                                                     // World handicap?
            {                                                                       // No - check tournament
            if ((t == null) || (!(t.equals(HandicapMain.TOURNINDICATOR))))          // Tournament score?
            {
                    //  ignore
            }

/*			Process tournament score
* 			Save off two lowest tournament scores
*/
            else                                                                // Yes - tournament
            {
                if (dateWithinYear(row))                                        // Is date in date range
                {                                                               // Yes
                    numberTournamentScores = numberTournamentScores + 1;        // Count it

                    if (saveDifferential < tournLowDiffOne)                     // Differential smaller than first lower?	
                    {
                        if (tournLowDiffTwo == 99 && tournLowDiffOne == 99)     // First of 2?
                                tournLowDiffOne = saveDifferential;             // Yes, save first lower
                        else							// No
                            if (tournLowDiffTwo != 99)                          // Do we have a 2nd?
                                    tournLowDiffTwo = saveDifferential;         // No, save 2nd
                            else
                            {
                                    if (saveDifferential < tournLowDiffTwo)     // Is it smaller than second?
                                            tournLowDiffTwo = saveDifferential; // Yes, replace second	
                            }
                    }
                    else
                    {
                        if (tournLowDiffTwo == 99)                              // Do we have a 2nd?
                                tournLowDiffTwo = saveDifferential;             // No, save 2nd
                        else
                        {
                                if (saveDifferential < tournLowDiffTwo)         // Is it smaller than second?
                                        tournLowDiffTwo = saveDifferential;     // Yes, replace second	
                        }
                    }
                }                                                               // Not within   
            }
            }                                                                   // World handicap, bypass tourn
        }
/*
 * 
 * 		Calculate average score and put in textfield on Display Scores
 * 
 */
            double total = totalOfAllScores;				// Total non 9 hole scores
            double number = numberNonNineHoleScores;			// Number of non 9 hole scores
            double averageScore = Math.floor((total / number) * 10) / 10;	// Truncate to .1
            DisplayScores.textDisplayScoresAverageScore.setText(String.valueOf(averageScore));	// Set *** textfield ***
            DisplayScores.textDisplayScoresNumberScores.setText(String.valueOf			// Set *** textfield ***
                (numberNonNineHoleScores));                                                     // Display number of scores
/*
 * 
 * 			Calculate number of scores in record that will be used
 * 			
 */
            int hcAdjustment = 0;               // World HC adjustment
            int nScores;                        // number of scores to use in latest record
            switch (numberNonNineHoleScoresInCurrentRecord)
            {
            case 20:
                nScores = 10;                   // if 20 -> 10
                if (worldHandicap)              // World HC?
                    nScores = 8;                // Best 8 of 20
                break;

            case 19:
                nScores = 9;			// If 19 -> 9
                if (worldHandicap)              // World HC?
                    nScores = 7;                // Yes, best 7 of 19
                break;

            case 18:
                nScores = 8;			// If 18 -> 8
                if (worldHandicap)              // World HC?
                    nScores = 6;                // Yes, best 6 of 18
                break;

            case 17:				// If 17 -> 7
                nScores = 7;
                if (worldHandicap)              // World HC?
                    nScores = 6;                // Yes, best 6 of 17
                break;

            case 16:				// If 15 or 16 -> 6
            case 15:
                nScores = 6;
                if (worldHandicap)              // World HC?
                    nScores = 5;                // Yes, best 5 of 15/16
                break;

            case 14:				// If 13 or 14 -> 5	
            case 13:
                nScores = 5;
                if (worldHandicap)              // World HC?
                    nScores = 4;                // Yes, best 6 of 18
                break;

            case 12:                            // If 11 or 12 -> 4
                nScores = 4;                   // Same for World HC     
                break;
                
            case 11:
                nScores = 4;
                if (worldHandicap)              // World HC?
                    nScores = 3;                // Yes, best 3 of 11
                break;
                
            case 10:				// if 9 or 10 -> 3
            case 9:
                nScores = 3;                    // Same for World HC
                break;

            case 8:                             // If 7 or 8 -> 2
            case 7:
                nScores = 2;                    // Same for World HC
                break;

            case 6:                             // If 5 or 6 -> 1
                nScores = 1;
                if (worldHandicap)              // World HC?
                {
                    nScores = 2;                // Yes, best 2 of 6
                    hcAdjustment = -1;          // World HC adjustment
                }
            case 5:
                nScores = 1;                    // Same for world HC
                break;
                
            case 4:
                nScores = 0;                    // Old HC
                if (worldHandicap)              // World HC?
                {
                    nScores = 1;                // Yes, best 1 of 4
                    hcAdjustment = -1;          // World HC adjustment
                }
                break;
                
            case 3:
                nScores = 0;                    // Old HC
                if (worldHandicap)              // World HC?
                {
                    nScores = 1;                // Yes, best 1 of 4
                    hcAdjustment = -2;          // World HC adjustment
                }
                break;

            default:				// Less than NH
                nScores = 0;

            }

            if (nScores == 0)			// Enough scores to calculate index?
            {
                hiIndex.newIndex = handicapIndex;	// No - return -99
                return hiIndex;
            }

/*
* 
* 		Sort last 20 or less differentials
* 
*/
            int temptableRowNumber;
            double tempDifferential;
            boolean finish = false;
            while (!finish)
            {
                for (int s = 1; s < numberNonNineHoleScoresInCurrentRecord; s++)
                {
                    finish = true;
                    for (int n = 0; n < (numberNonNineHoleScoresInCurrentRecord) - s; n++)
                    {
                        if (indexArray[n].differential > indexArray[n + 1].differential)
                        {
                            tempDifferential = indexArray[n + 1].differential;
                            temptableRowNumber = indexArray[n + 1].tableRowNumber;
                            indexArray[n + 1].differential = indexArray[n].differential;
                            indexArray[n + 1].tableRowNumber = indexArray[n].tableRowNumber;
                            indexArray[n].differential = tempDifferential;
                            indexArray[n].tableRowNumber = temptableRowNumber;
                            finish = false;				
                        }
                    }
                }

            }
/*
* 		Set score used
*/
            double totalDifferential = 0;

            for (int row = 0; row < nScores; row++)
            {
                tableDisplayScores.setValueAt("*", indexArray[row].tableRowNumber, uPosition);	// Set used
                totalDifferential = totalDifferential + indexArray[row].differential;

//					System.out.println("Row: " + indexArray[row].tableRowNumber + " Index: " + indexArray[row].differential);
            }
/*
* 		Calculate handicap index
*/
            double scores;
            scores = nScores;                                           // Convert to double
/*
            World handicap has a .96 modifier to th HI and truncates to tenths.  WHC rounds to tenths
*/          
            double hModifier = .96;                                     // Old modifier
            double round = 0;                                           // No rounding for non WHC
            if (worldHandicap)                                          // World HC?
            {
                hModifier = 1;                                          // Yes, no adjustment
                round = .05F;                                           // Round to tenths
            }
            handicapIndex = Math.floor(((totalDifferential / scores + round) *
                    hModifier) * 10) / 10;                              // Truncate to .1

//				Calculate tournament adjustment

            double tournamentAdjustment = -99;                      // default no adjustment
            if (worldHandicap)                                      // World HC?
            {                                                       // Yes               
                String userHANDICAPHI = HandicapMain.userName + HandicapMain.HANDICAPHI;
                String prevIndexS = HandicapMain.handicapPrefs.get(userHANDICAPHI, 
                        HandicapMain.NOHI);                                         // Previous HI from preferences
                if (prevIndexS.equals(HandicapMain.NOHI))
                {
                    System.out.println("No HI");                                    // Message, get out
                    prevIndexS = Double.toString(handicapIndex);                    // Make it same as index
                }

                if (prevIndexS.equals("NH"))
                {
                    System.out.println("No NH");                                    // Message, get out
                    prevIndexS = Double.toString(handicapIndex);                    // Make it same as index
                }
                double prevIndex = Double.parseDouble(prevIndexS);                  // Convert previous index to double
                
//              Get low HI from prefs               
                String userHANDICAPLOWHI = HandicapMain.userName + HandicapMain.HANDICAPLOWHI;
                String lowHIS = HandicapMain.handicapPrefs.get(userHANDICAPLOWHI, 
                        HandicapMain.NOLOW);                                        // Low HI from preferences
                if (lowHIS.equals(HandicapMain.NOLOW))                              // Have one?
                {
                    System.out.println("No Low HI, enter in preferences");          // Message, get out
                    lowHIS = "40";                                                  // Set to something
                }
                double lowIndex = Double.parseDouble(lowHIS);                       // Convert low index to double
//              Apply soft cap?             
                double cappedHandicapIndex = 
                        calcSoftCap(handicapIndex, lowIndex, hiIndex);              // Check if need soft cap
              
                if (cappedHandicapIndex != handicapIndex)                           // Soft capped?
                {     
//                  Apply hard cap?
                    cappedHandicapIndex = 
                        calcHardCap(cappedHandicapIndex, lowIndex, hiIndex);        // Yes, check for hard cap 
                    tournamentAdjustment = cappedHandicapIndex;                     // Put soft/hard cap tournamentAdjustment
                }
            }
            else                                                                    // No
            {                                                                       // Adjust for tourn
                double two = 2D;
                if (numberTournamentScores > 1)                                     // 2 or more tournament scores?
                {
                    // Make tournament adjustment if handicap index - 2nd lowest tournament diff > 3

                    if (handicapIndex - Math.max(tournLowDiffOne, tournLowDiffTwo) > 3)
                    {
                        double tournDiffAverage = (tournLowDiffOne + tournLowDiffTwo) / two;
                        double tournDiffAverageRnd = Math.floor((tournDiffAverage) * 10) / 10;
                        tournamentAdjustment = calcTournamentAdjustment(handicapIndex - tournDiffAverageRnd,	
                                numberTournamentScores, hiIndex);                    // Yes, calculate adjustment
                    }
                }
            }           
            hiIndex.newIndex = handicapIndex;                                       // Set HI
            hiIndex.newIndexAdjusted = tournamentAdjustment;                        // Set HI adjustment
            if (exceptionalScore)
            {
                hiIndex.newIndexAdjusted = hiIndex.newIndex;                        // Put something in to force (S/H)
            }

/*
        This code determines if the new HI is < the low HI kept in prefs.
        If it is lower this becpmes the new low.
*/
        String userHANDICAPLOWHI = HandicapMain.userName + HandicapMain.HANDICAPLOWHI;
        String lowHIS = HandicapMain.handicapPrefs.get(userHANDICAPLOWHI, 
                HandicapMain.NOLOW);                                                // Low HI from preferences
        String newHI;
        Double dblLowHI;
        Double dblNewIndex;
        boolean putLowHI = false;                                                   // Need ro save low HI
        if (hiIndex.newIndexAdjusted == -99D)                                       // Adjusted HI?
        {
            newHI = Double.toString(hiIndex.newIndex);                             // Use standard HI
            dblNewIndex = hiIndex.newIndex;
        }
        else                                                                        // Yes
        {
            newHI = Double.toString(hiIndex.newIndexAdjusted);                      // Use adjusted
            dblNewIndex = hiIndex.newIndexAdjusted;
        }
        if (lowHIS.equals(HandicapMain.NOLOW))                                      // Have one?
        {
            Preferrences.textPreferencesLHI.setText(newHI);                         // No Low HI, use what we have
            putLowHI = true;                                                        // Write to prefs
        }
        else
        {
            dblLowHI = Double.parseDouble(lowHIS);                                  // Low HI from prefs
            if (dblNewIndex < dblLowHI)
            {
                Preferrences.textPreferencesLHI.setText(newHI);                     // Set new low HI
                putLowHI = true;                                                    // Write to prefs
            }
        }
        if (putLowHI)                                                               // Write prefs?
        {
            HandicapMain.handicapPrefs.put(userHANDICAPLOWHI,newHI);                //  Save low HI
            try                              
            {
                HandicapMain.handicapPrefs.flush();                                 // Make all preferences changes permanent
            }
            catch (BackingStoreException ex)
            {
                Logger.getLogger(HandicapMain.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
            return hiIndex;                                                         // Handicap index and T adjustment
    }

/**
 * 
 * @param handicapIndex  - calculated handicap index
 * @param lowIndex - low index from handicapPrefs
 * @return cappedHandicapIndex
 * 
 * lowIndex - Lowest index for last 365 days*, stored in preferences, updated on preferences screen
 * Soft cap - invoked when (LHI + 3) LT (HI) LT= LHI + 5, increase limited to 50% of increase above
 * Hard cap - LHI + 5
 */
    private static double calcSoftCap(double handicapIndex, double lowIndex, HandicapIndices hiIndex)
    {
        double cappedHandicapIndex = handicapIndex;                                 // Assume no cap
        double softCap = lowIndex + 3D;                                             // Soft cap
        if (handicapIndex > softCap)
        {
/*
                Capped HI = half the increase above the soft cap
                ie Low HI = 10
                   Soft cap starts at 13 (Low HI + 3)
                   New index is 13.7
                   1/2 ( 13.7 - 13) = .35
                  Capped index = cap + .35 = 13.35 (rounded to 13.4)
*/
            cappedHandicapIndex = 0.5*(handicapIndex - softCap) + softCap;          // Capped
            cappedHandicapIndex = Math.floor((cappedHandicapIndex + .05D) 
                    * 10) / 10;                                                     // Rounded to tenths
            hiIndex.adjustedType = "S";                                             // Soft cap
        }
        return cappedHandicapIndex;
    }

    /**
     * This method checks for and applies hard cap if 5 above low index
     * @param handicapIndex - calculated index or soft capped index
     * @param lowIndex - low index from prefs
     * @return 
     */
    private static double calcHardCap(double handicapIndex, double lowIndex, HandicapIndices hiIndex)
    {
        double hardCap = lowIndex + 5D;                                             // Hard cap
        double cappedHandicapIndex = handicapIndex;                                 // Default capped to existing
        if (handicapIndex > hardCap)
        {
            cappedHandicapIndex = hardCap;                                          // Capped
            cappedHandicapIndex = Math.floor((cappedHandicapIndex + .05D) 
                    * 10) / 10;                                                     // Rounded to tenths
            hiIndex.adjustedType = "H";                                             // Hard cap
        }       
        return cappedHandicapIndex;
    }
    
/**
 * This method checks to see if the date of displayed score is within the past year
 * Returns true if within past year otherwise false
 * @param row
 * @return 
 */
    private static boolean dateWithinYear(int row)
    {
        String tempDate = (String) tableDisplayScores.getModel().
                getValueAt(row, HandicapMain.DATE_POS);                         // Date of score
        DateFormat df = new SimpleDateFormat("MM/dd/yy");                       // Conversion
        Date dTempDate = null;
        try
        {
            dTempDate = df.parse(tempDate);                                     // Convert to Date obj
        }
        catch (ParseException ex)
        {
            Logger.getLogger(DisplayScores.class.getName()).log(Level.SEVERE, null, ex);
        }
        Date currDate = Calendar.getInstance().getTime();                       // Current date
        Long diff;                                  
        diff = currDate.getTime() - dTempDate.getTime();                        // Days between in mili secs
        int diffDays = (int) (diff / (24 * 60 * 60 * 1000));                    // Convert days between to days
        boolean withinYr;                                                       // Within year
        if (diffDays > 365)                                                     // Past year?
            withinYr = false;                                                   // No
        else
            withinYr = true;                                                    // Yes
        return withinYr;
    }

    private static double calcTournamentAdjustment(double handicapIndex, int numberTournamentScores, HandicapIndices hiIndex)
    {

        //  Tournament adjustment table
        double[][] tournTable = new double[][]
        //   idx   2 3 4 5-9 10-19 20-29 30-39 =>40
        {
            {3.5, 0, 0, 0, 0, 0, 0, 0, 0},                          // 3.0 - 3.4
            {4, 0, 0, 0, 0, 0, 0, 0, 0},                            // 3.5 - 3.9
            {4.5, 1, 0, 0, 0, 0, 0, 0, 0},                          // 4.0 - 4.4 
            {5, 1.8, 1, 0, 0, 0, 0, 0, 0},                          // 4.5 - 4.9
            {5.5, 2.6, 1.9, 1, 0, 0, 0, 0, 0},                      // 5.0 - 5.4
            {6, 3.4, 2.7, 1.9, 1, 0, 0, 0, 0},                      // 5.5 - 5.9
            {6.5, 4.1, 3.5, 2.8, 1.9, 1, 0, 0, 0},                  // 6.0 - 6.4
            {7, 4.8, 4.3, 3.7, 2.9, 2, 1, 0, 0},                    // 6.5 - 6.9
            {7.5, 5.5, 5, 4.5, 3.8, 3, 2.1, 1, 0},                  // 7.0 - 7.4
            {8, 6.2, 5.7, 5.3, 4.7, 3.9, 3.1, 2.2, 1},              // 7.5 - 7.9
            {8.5, 6.8, 6.4, 6, 5.5, 4.8, 4.1, 3.2, 2.2},            // 8.0 - 8.4
            {9, 7.4, 7.1, 6.7, 6.2, 5.7, 5, 4.2, 3.3},              // 8.5 - 8.9
            {9.5, 8.1, 7.8, 7.4, 7, 6.5, 5.9, 5.2, 4.4},            // 9.0 - 9.4
            {10, 8.7, 8.4, 8.1, 7.7, 7.3, 6.7, 6.1, 5.4},           // 9.5 - 9.9
            {10.5, 9.2, 9, 8.8, 8.4, 8, 7.6, 7, 6.4},               // 10.0 - 10.4
            {11, 9.8, 9.5, 9.4, 9.1, 8.7, 8.3, 7.8, 7.2},           // 10.5 - 10.9
            {11.5, 10.4, 10.2, 10, 9.7, 9.4, 9.1, 8.6, 8.1},        // 11.0 - 11.4
            {12, 11, 10.8, 10.6, 10.4, 10.1, 9.8, 9.4, 8.9},        // 11.5 - 11.9
            {12.5, 11.5, 11.4, 11.2, 11, 10.7, 10.5, 10.1, 9.7},    // 12.0 - 12.4
            {13, 12.1, 11.9, 11.8, 11.6, 11.4, 11.1, 10.8, 10.5},   // 12.5 - 12.9
            {13.5, 12.6, 12.5, 12.4, 12.2, 12, 11.8, 11.5, 11.2},   // 13.0 - 13.4
            {14, 13.2, 13.1, 12.9, 12.8, 12.6, 12.4, 12.2, 11.9},   // 13.5 - 13.9
            {99, 13.7, 13.6, 13.5, 13.4, 13.2, 13, 12.8, 12.6}      // 14.0 or more
        };

        int column;
        int row;

// 		Number of tournament scores determine column in table
        if (numberTournamentScores < 5)
        {
            column = numberTournamentScores - 1;
        } 
        else
        {
            if (numberTournamentScores < 10)
            {
                column = 4;
            } 
            else
            {
                if (numberTournamentScores < 20)
                {
                    column = 5;
                } 
                else
                {
                    if (numberTournamentScores < 30)
                    {
                        column = 6;
                    } 
                    else
                    {
                        if (numberTournamentScores < 40)
                        {
                            column = 7;
                        } 
                        else
                        {
                            column = 8;
                        }
                    }
                }
            }
        }

//		Unadjusted handicap index - average of low 2 tournament diffs determines row in table 
        for (row = 0; row < tournTable.length; row++)
        {
            if (handicapIndex < tournTable[row][0])		// Search for next highest HI in table column 0
            {
                break;
            }
        }
        hiIndex.adjustedType = "R";                                                 // Tournament adjustment
        return tournTable[row][column];					// Amount of adjustment
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnBack;
    private javax.swing.JButton btnCalculateCourseHandicap;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel panelCenter;
    private javax.swing.JPanel panelSouth;
    private javax.swing.JScrollPane scrollPane;
    public static javax.swing.JTable tableDisplayScores;
    public static javax.swing.JTextField textDisplayScoresAverageScore;
    public static javax.swing.JTextField textDisplayScoresIndex;
    public static javax.swing.JTextField textDisplayScoresIndexAdj;
    public static javax.swing.JTextField textDisplayScoresNumberScores;
    // End of variables declaration//GEN-END:variables
}
